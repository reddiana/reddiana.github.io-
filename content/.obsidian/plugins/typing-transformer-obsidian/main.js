/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __toBinary = /* @__PURE__ */ (() => {
  var table = new Uint8Array(128);
  for (var i = 0; i < 64; i++)
    table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
  return (base64) => {
    var n = base64.length, bytes = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
    for (var i2 = 0, j = 0; i2 < n; ) {
      var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
      var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
      bytes[j++] = c0 << 2 | c1 >> 4;
      bytes[j++] = c1 << 4 | c2 >> 2;
      bytes[j++] = c2 << 6 | c3;
    }
    return bytes;
  };
})();

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypingTransformer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_state2 = require("@codemirror/state");
var import_view3 = require("@codemirror/view");

// wasm-binary:/home/runner/work/typing-transformer-obsidian/typing-transformer-obsidian/liberty-web/charliberty_bg.wasm
var charliberty_bg_exports = {};
__export(charliberty_bg_exports, {
  default: () => charliberty_bg_default
});
var charliberty_bg_default = __toBinary("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hMLAAEH/HyAAIABB/x9NGzYCACADIARPDQBB/MHAAEF/NgIACwvJBQELfyMAQSBrIgUkACABKAJQIQogASgCTCEIIAEoAkghCSABKAIIIQsgBUEYaiABEA4gBSgCHCEBAkACQAJAAkACQCAFKAIYDQAgCSABKAJIRw0CIAggASgCTEcNAiABKAJQIQQgASgCLCIDIAEoAiRGBEAgAUEkahBKCyABKAIoIANBFGxqIgIgBDYCECACIAo2AgwgAiAINgIIIAIgCTYCBCACQQA2AgAgASADQQFqNgIsIAEoAjgiAyABKAIwRgRAIAFBMGoQSwsgASgCNCADQQR0aiICIAQ2AgwgAiAKNgIIIAIgCDYCBCACIAk2AgAgASADQQFqNgI4IAVBEGogARAiIAUoAhQhASAFKAIQRQRAA0AgBUEIaiABECIgBSgCDCEBIAUoAghFDQALCyABKAI4IgJFDQMgASACQQFrIgI2AjggASgCNCACQQR0aiIDKAIAIgdFDQMgAygCDCEEIAMoAgghAiADKAIEIQMgASgCLCIMIAEoAiRGBEAgAUEkahBKCyABKAIoIAxBFGxqIgYgBDYCECAGIAI2AgwgBiADNgIIIAYgBzYCBCAGQQE2AgAgASAMQQFqNgIsIAIgBEsNBAJAIAJFDQAgAiADSQRAIAIgB2osAABBv39KDQEMBgsgAiADRw0FCwJAIARFDQAgAyAESwRAIAQgB2osAABBv39MDQYMAQsgAyAERw0FCyABKAJQIgMgBCACayIGaiIEIANJDQAgBCABKAJMSw0AIAIgB2ogASgCSCADaiAGEHENACABIAQ2AlBBACECDAELIAEgCjYCUCABIAg2AkwgASAJNgJIQQEhAiABKAIIIAtJDQAgASALNgIICyAAIAE2AgQgACACNgIAIAVBIGokAA8LQfiBwABBMUGIg8AAEIUBAAtB4IPAAEEdQYCEwAAQbgALIAcgAyACIARB6IHAABCZAQAL9AQBCH8jAEEwayICJAAgASABLQBYIgRBAUc6AFggASgCLCEFIAEoAlAhByABKAJMIQggASgCSCEGIAEoAgghCSABKAJEIgMgASgCPEYEQCABQTxqEEwLIAEoAkAgA0ECdGogBTYCACABIANBAWo2AkQgAkEoaiABEBFBACEDAn8gAigCLCIBIAIoAihFDQAaIAJB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QQhqIAEQfCACIAIoAgggAigCDCgCGBEAACACKAIEIQEgACACKAIANgIAIAAgATYCBCACQRBqJAALTwECf0GNvsAALQAAGiABKAIEIQIgASgCACEDQQhBBBChASIBRQRAQQRBCBC2AQALIAEgAjYCBCABIAM2AgAgAEGcn8AANgIEIAAgATYCAAtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEFAgACgCCCEDCyAAKAIEIANqIAEgAhA6GiAAIAIgA2o2AghBAAvnAQEFfyMAQRBrIgMkACAAKAIARQRAAAsgA0EIaiEFIwBBIGsiAiQAIAJBEGogAEGwjsAAKAIAIgQRAAACQCAAAn8gAikDEEL4gpm9le7Gxbl/UQRAQQQgAikDGELtuq22zYXU9eMAUQ0BGgsgAiAAIAQRAABB5J/AACEEQQwhBiACKQMAQpffgNjX8qSvKlINASACKQMIQtmp8YjEw53+v39SDQEgAEEEaiEAQQgLaigCACEGIAAoAgAhBAsgBSAGNgIEIAUgBDYCACACQSBqJAAgASADKAIIIAMoAgwQlgEgA0EQaiQAC0EBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEHMACzwBAn8gACgCCCECIAAoAiAiASAAKAIYRgRAIABBGGoQTAsgACgCHCABQQJ0aiACNgIAIAAgAUEBajYCIAs+AQF/IwBBEGsiAiQAIAJBCGogASABKAIAKAIEEQAAIAIoAgwhASAAIAIoAgg2AgAgACABNgIEIAJBEGokAAvEAgEDfyAAKAIAIQIgASgCHCIAQRBxRQRAIABBIHFFBEAgAiABEKgBDwtBACEAIwBBgAFrIgQkACACKAIAIQIDQCAAIARqQf8AaiACQQ9xIgNBMHIgA0E3aiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAkGAAUHcpMAAEGYACyABQeykwABBAiAAIARqQYABakEAIABrEB8gBEGAAWokAA8LQQAhACMAQYABayIEJAAgAigCACECA0AgACAEakH/AGogAkEPcSIDQTByIANB1wBqIANBCkkbOgAAIABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAU8EQCACQYABQdykwAAQZgALIAFB7KTAAEECIAAgBGpBgAFqQQAgAGsQHyAEQYABaiQACzEBAX9BBCEBAkAgABCLAUUNACAABEBBjb7AAC0AABogAEEEEKEBIgFFDQELIAEPCwALOAACQCACQYCAxABGDQAgACACIAEoAhARAQBFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAgALLwEBfyMAQRBrIgIkACACQQhqIAAQfCACKAIIIAEgAigCDCgCEBEBACACQRBqJAALOQEBf0EBIQICQCAAIAEQOw0AIAEoAhRB2aHAAEECIAEoAhgoAgwRAgANACAAQQRqIAEQOyECCyACCzkBAX8jAEEgayIAJAAgAEEANgIYIABBATYCDCAAQdinwAA2AgggAEIENwIQIABBCGpBiKjAABBzAAs4AQF/QQEhASAALQAERQRAIAAoAgAiASgCFEHGpMAAQQEgASgCGCgCDBECACEBCyAAIAE6AAQgAQswACAAIAEoAhRBAUEAIAEoAhgoAgwRAgA6AAggACABNgIEIABBAToACSAAQQA2AgALUAEBfyMAQRBrIgMkACADIAI2AgwgAyABNgIIIAMgADYCBCMAQRBrIgAkACAAIANBBGoiASkCADcCCCAAQQhqQcSKwAAgASgCCEEBQQAQTQALMQEBfyAAIAEoAkxBDSABKAJQQYCAgIB4RiICGzYCBCAAIAEoAkhBtJnAACACGzYCAAsyAQF/IAEoAhRB9KHAAEEBIAEoAhgoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsfAAJAIAEQiwEEQCAAIAFBBCACEJQBIgANAQsACyAACygAIAEgACgCAC0AAEECdCIAQfSUwABqKAIAIABBhJTAAGooAgAQlgELJAEBfyAAKAIAIgFBgICAgHhGIAFFckUEQCAAKAIEIAEQpwELCwsAIABB/P///wdNCyYBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAEQpwELCygAIABBBGpBACACQoGJ1q7b3qfJoX9RG0EAIAFCq56MuJSNprljURsLHQAgASgCAEUEQAALIABBpI7AADYCBCAAIAE2AgALHAAgACgCACIAQQRqKAIAIABBCGooAgAgARC5AQsYAQF/IAAoAgAiAQRAIAAoAgQgARCnAQsLRQAg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ZSBjb2RlaAQQAFwAAACtAAAAGQAAAAAAAAAIAAAABAAAAAUAAAAGAAAABwAAAAgAAAAAAAAABAAAAAQAAAACAAAAAQAAAAAAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9wZXN0LTIuMS4zL3NyYy9zdGFjay5ycwAAAHgFEABZAAAAWQAAACYAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9wZXN0LTIuMS4zL3NyYy9pdGVyYXRvcnMvcGFpci5ycwAA5AUQAGIAAAD6AAAAGQAAAOQFEABiAAAA8QAAABkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2Rl5AUQAGIAAAD1AAAAEgAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3Blc3QtMi4xLjMvc3JjL2l0ZXJhdG9ycy9wYWlycy5ycwCgBhAAYwAAAMMAAAAZAAAAoAYQAGMAAADHAAAAEgAAAAAAAAAIAAAABAAAAAkAAABhdHRlbXB0IHRvIGpvaW4gaW50byBjb2xsZWN0aW9uIHdpdGggbGVuID4gdXNpemU6Ok1BWC9ydXN0Yy9mNmU1MTFlZWM3MzQyZjU5YTI1ZjdjMDUzNGYxZGJlYTAwZDAxYjE0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0ci5ycwAAAGkHEABIAAAAmQAAAAoAAABtaWQgPiBsZW4AAADEBxAACQAAAGkHEABIAAAAsAAAABYAAAAKAAAABAAAAAQAAAALAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZXNyYy9saWIucnMAAAAjCBAACgAAAAsAAAAaAAAAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcGVzdC0yLjEuMy9zcmMvaXRlcmF0b3JzL3BhaXIucnMAAEAIEABiAAAAdAAAABQA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AAA7AAAAPAAAAD0AAAA+AAAAEAAAAAQAAAA/AAAAQAAAAEEAAABCAAAAQm94PGR5biBBbnk+RXJyb3IAAABDAAAADAAAAAQAAABEAAAARQAAAEYAAABjYXBhY2l0eSBvdmVyZmxvdwAAABAQEAARAAAAYWxsb2Mvc3JjL3Jhd192ZWMucnMsEBAAFAAAABgAAAAFAEHYoMAAC7IdAQAAAEcAAABhIGZvcm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3Igd2hlbiB0aGUgdW5kZXJseWluZyBzdHJlYW0gZGlkIG5vdGFsbG9jL3NyYy9mbXQucnMAALYQEAAQAAAAfgIAAA4AAAApLi4wMTIzNDU2Nzg5YWJjZGVmAAEAAAAAAAAAW2NhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAIBEQACAAAABAERAAEgAAAAAAAAAEAAAABAAAAE0AAAA9PSE9bWF0Y2hlc2Fzc2VydGlvbiBgbGVmdCAgcmlnaHRgIGZhaWxlZAogIGxlZnQ6IAogcmlnaHQ6IAB/ERAAEAAAAI8REAAXAAAAphEQAAkAAAAgcmlnaHRgIGZhaWxlZDogCiAgbGVmdDogAAAAfxEQABAAAADIERAAEAAAANgREAAJAAAAphEQAAkAAAA6IAAAAQAAAAAAAAAEEhAAAgAAAAAAAAAMAAAABAAAAE4AAABPAAAAUAAAACAgICAgeyAsICB7CiwKfSB9KCgKLApdY29yZS9zcmMvZm10L251bS5ycwAARxIQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9m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");

// liberty-web/charliberty.js
var wasm;
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
function formatLine(line) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.formatLine(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
var cachegetUint32Memory0 = null;
function getUint32Memory0() {
  if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachegetUint32Memory0;
}
function getArrayU32FromWasm0(ptr, len) {
  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);
}
function getBlockRanges(line, cursor_pos) {
  const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getBlockRanges(ptr0, len0, cursor_pos);
  return Blocks.__wrap(ret);
}
var Blocks = class {
  static __wrap(ptr) {
    const obj = Object.create(Blocks.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_blocks_free(ptr);
  }
  get special() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.blocks_special(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v0 = getArrayU32FromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 4);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  get emphasis() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.blocks_emphasis(retptr, this.ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var v0 = getArrayU32FromWasm0(r0, r1).slice();
      wasm.__wbindgen_free(r0, r1 * 4);
      return v0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
function load(module2, imports) {
  return __async(this, null, function* () {
    if (typeof Response === "function" && module2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return yield WebAssembly.instantiateStreaming(module2, imports);
        } catch (e) {
          if (module2.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = yield module2.arrayBuffer();
      return yield WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = yield WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  });
}
function init(input) {
  return __async(this, null, function* () {
    if (typeof input === "undefined") {
      input = new URL("charliberty_bg.wasm", "");
    }
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
      input = fetch(input);
    }
    const { instance, module: module2 } = yield load(yield input, imports);
    wasm = instance.exports;
    init.__wbindgen_wasm_module = module2;
    return wasm;
  });
}
var charliberty_default = init;

// src/const.ts
var FW;
((FW2) => {
  FW2.DOT = "\xB7";
  FW2.MONEY = "\uFFE5";
  FW2.FULLSTOP = "\u3002";
  FW2.LT = "\u300A";
  FW2.GT = "\u300B";
  FW2.SLASH = "\u3001";
  FW2.LEFTQUO = "\u201C";
  FW2.RIGHTQUO = "\u201D";
  FW2.LEFTPAREN = "\uFF08";
  FW2.RIGHTPAREN = "\uFF09";
})(FW || (FW = {}));
var SW;
((SW2) => {
  SW2.DOT = "`";
  SW2.MONEY = "$";
  SW2.FULLSTOP = ".";
  SW2.LT = "<";
  SW2.GT = ">";
  SW2.SLASH = "/";
  SW2.LEFTQUO = '"';
  SW2.RIGHTQUO = '"';
  SW2.LEFTPAREN = "(";
  SW2.RIGHTPAREN = ")";
})(SW || (SW = {}));
var PUNCTS = new Set(" \uFF0C\u3002\uFF1A\uFF1F,.:?");
var DEFAULT_RULES = String.raw`
# Line head conversion
# Note: this rule can't apply to the very first line of the document
'\n》|' -> '\n>|'
'\n、|' -> '\n/|'

# CN symbols to EN
'。。|' -> '.|'
'》》|' -> '>|'
'、、|' -> '/|'
'；；|' -> ';|'
'，，|' -> ',|'

# Auto-pair, Input Conversion, and Deletion
'《《|》' -> '<|' # this one take higer priority than the next line
'《|'    -> '《|》'
'《|》'   -x '|'
'（（|）' -> '(|)'
'（|'     -> '（|）'
'（|）'   -x '|'

# Auto code block
'··|'  -> '\`|\`' # inline block
'\`·|\`' -> '\`\`\`|\n\`\`\`'

# have fun converting!
'dpx|' -> 'don\'t panic|'


# Selection Insert Rules
'·'  -> '\`' + '\`'
'￥'  -> '$' + '$'
'《'  -> '《' + '》'
'<'  -> '<' + '>'
`.replaceAll("\\`", "`");

// src/utils.ts
var config;
function initLog(cfg) {
  config = cfg;
}
function log(format, ...parts) {
  if (config != void 0 && config.debug) {
    parts.forEach((v, idx) => {
      if (typeof v === "string" || v instanceof String) {
        parts[idx] = JSON.stringify(v);
      }
    });
    console.log(format, ...parts);
  }
}

// src/ext_convert.ts
var EOF = "EOF";
var ANCHOR = "\xA6";
var DEL_TRIG = "\u274C";
var ParseResult = class {
  constructor(value, error) {
    this.value = value;
    this.error = error;
  }
  get isOk() {
    return this.error == "";
  }
};
function Ok(val) {
  return new ParseResult(val, "");
}
function Err(err) {
  return new ParseResult(null, err);
}
function findOnlyAnchor(s) {
  let res = -1, idx = 0;
  for (const ch of s) {
    if (ch === ANCHOR) {
      if (res == -1) {
        res = idx;
      } else {
        return -2;
      }
    }
    idx++;
  }
  return res;
}
function prefixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = 0; i < s1.length; i++) {
    if (s1[i] != s2[i])
      return false;
  }
  return true;
}
function suffixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = s1.length - 1, j = s2.length - 1; i > -1; i--, j--) {
    if (s1[i] != s2[j])
      return false;
  }
  return true;
}
var Rule = class {
};
var SideRule = class {
  constructor(trig, left, right) {
    this.trig = trig;
    this.left = left;
    this.right = right;
  }
  get isValid() {
    return this.trig.length === 1;
  }
};
var ConvRule = class {
  constructor(left, right, isForDelete = false) {
    this.isForDelete = isForDelete;
    this.left = Array.from(left);
    this.right = Array.from(right);
    this.lanchor = findOnlyAnchor(this.left);
    this.ranchor = findOnlyAnchor(this.right);
    if (this.lanchor > 0 && isForDelete) {
      this.left.splice(this.lanchor, 0, DEL_TRIG);
      this.lanchor += 1;
    }
    this.innerTrig = this.left[this.lanchor - 1];
    this.rBeforeAnchorLen = this.right.slice(0, this.ranchor).reduce((acc, cur) => acc + cur.length, 0);
    this.lBefore2AnchorLen = this.left.slice(0, this.lanchor - 1).reduce((acc, cur) => acc + cur.length, 0);
    this.lAfterAnchorLen = this.left.slice(this.lanchor + 1).reduce((acc, cur) => acc + cur.length, 0);
    this.replace = this.right.slice(0, this.ranchor).join("") + this.right.slice(this.ranchor + 1).join("");
  }
  get isValid() {
    return this.lanchor > 0 && this.ranchor >= 0;
  }
  invalidReasons() {
    const reasons = [];
    if (this.lanchor < 0) {
      reasons.push(`Expected one | on left side, but found ${this.lanchor == -1 ? "none" : "multiple"}`);
    } else if (this.lanchor === 0) {
      reasons.push("Invalid Placement of | on the left side. Note: left side cannot start with |");
    }
    if (this.ranchor < 0) {
      reasons.push(`Expected one | on right side, but found ${this.ranchor == -1 ? "none" : "multiple"}`);
    }
    return reasons.join("\n");
  }
  get trigHintChar() {
    if (this.isForDelete) {
      return this.left[this.lanchor - 2];
    } else {
      return this.left[this.lanchor - 1];
    }
  }
  canConvert(inputS, insChr, insPosBaseHead) {
    const input = Array.from(inputS);
    if (!this.isValid || insChr != this.innerTrig)
      return false;
    const { left, lanchor } = this;
    if (!suffixOf(left.slice(0, lanchor - 1), input.slice(0, insPosBaseHead)))
      return false;
    return prefixOf(left.slice(lanchor + 1), input.slice(insPosBaseHead));
  }
  leftMatchPart() {
    return this.left.slice(0, this.lanchor);
  }
  mapToChanges(pos) {
    const { lBefore2AnchorLen, lAfterAnchorLen, rBeforeAnchorLen } = this;
    const from = pos - lBefore2AnchorLen;
    const to = pos + lAfterAnchorLen;
    const newPos = from + rBeforeAnchorLen;
    return {
      changes: { from, to, insert: this.replace },
      selection: { anchor: newPos, head: newPos }
    };
  }
};
var readable = JSON.stringify;
var RuleParser = class {
  constructor(input) {
    this.idx = 0;
    this.input = Array.from(input);
    this.convRules = [];
    this.sideRules = /* @__PURE__ */ new Map();
    this.errors = [];
  }
  peek() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[idx];
  }
  eat() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[this.idx++];
  }
  rewind() {
    this.idx--;
  }
  ignoreSpace() {
    while (this.peek() === " ") {
      this.eat();
    }
  }
  parseString() {
    this.ignoreSpace();
    if (this.peek() != "'") {
      return Err("Expected a rule starting with ', but found " + readable(this.peek()));
    }
    this.eat();
    const result = [];
    let ch;
    while (true) {
      ch = this.eat();
      switch (ch) {
        case "\\":
          switch (this.peek()) {
            case "'":
            case "\\":
              result.push(this.eat());
              break;
            case "n":
              this.eat();
              result.push("\n");
              break;
            default:
              result.push(ch);
              break;
          }
          break;
        case "'":
          return Ok(result.join(""));
        case "\n":
          return Err("Expected a rule ending with ', but found newline. Note: escape intentional newline with '\\n'");
        case EOF:
          return Err("Expected a rule ending with ', but found nothing");
        default:
          result.push(ch);
          break;
      }
    }
  }
  parseMapArrow() {
    this.ignoreSpace();
    const first = this.eat(), second = this.eat();
    if (first === "-" && second === ">") {
      return Ok(0 /* Insert */);
    } else if (first === "-" && second === "x") {
      return Ok(1 /* Delete */);
    }
    return Err(`Expected -> or -x, but found ${readable(first)}${readable(second)}`);
  }
  parseComment() {
    this.ignoreSpace();
    let ch = this.peek();
    if (ch === "#") {
      while (ch != "\n" && ch != EOF) {
        ch = this.eat();
      }
      if (ch === "\n") {
        this.rewind();
      }
    }
    if (ch != "\n" && ch != EOF) {
      return Err("Expected only one rule in each line, but found " + readable(ch));
    }
    return Ok("#no content#");
  }
  isSideRule() {
    this.ignoreSpace();
    const ch = this.peek();
    if (ch != "+") {
      return false;
    } else {
      this.eat();
      return true;
    }
  }
  parseOne() {
    const r1 = this.parseString();
    if (!r1.isOk) {
      return Err(r1.error);
    }
    const r2 = this.parseMapArrow();
    if (!r2.isOk) {
      return Err(r2.error);
    }
    const r3 = this.parseString();
    if (!r3.isOk) {
      return Err(r3.error);
    }
    const rule = new Rule();
    if (this.isSideRule()) {
      if (r2.value === 1 /* Delete */) {
        return Err("Expected ->, but found -x. Note: selection rules cannot be deletion rules");
      }
      const rightInsert = this.parseString();
      if (!rightInsert.isOk) {
        return Err(rightInsert.error);
      }
      const sideRule = new SideRule(r1.value, r3.value, rightInsert.value);
      if (!sideRule.isValid) {
        return Err("Expected one char, but found multiple. Note: the selection rule trigger char can only be a single character");
      }
      rule.type = 1 /* SideRule */;
      rule.side = sideRule;
    } else {
      const convRule = new ConvRule(r1.value, r3.value, r2.value === 1 /* Delete */);
      if (!convRule.isValid) {
        return Err(convRule.invalidReasons());
      }
      rule.type = 0 /* ConvRule */;
      rule.conv = convRule;
    }
    const r4 = this.parseComment();
    if (!r4.isOk) {
      return Err(r4.error);
    }
    return Ok(rule);
  }
  parse() {
    let line = 1;
    while (true) {
      const r = this.parseComment();
      if (!r.isOk) {
        const rRes = this.parseOne();
        if (!rRes.isOk) {
          for (const msg of rRes.error.split("\n")) {
            this.errors.push(`line ${line}: ` + msg);
          }
        } else if (rRes.value.type === 0 /* ConvRule */) {
          this.convRules.push(rRes.value.conv);
        } else {
          const s = rRes.value.side;
          this.sideRules.set(s.trig, { l: s.left, r: s.right });
        }
      }
      const ch = this.eat();
      if (ch === "\n") {
        line++;
      } else {
        break;
      }
    }
  }
};
var Rules = class {
  constructor(ruletxt, justCheck = false) {
    const unescapedTxt = ruletxt.replaceAll("\\|", "{0v0}").replaceAll("|", ANCHOR).replaceAll("{0v0}", "|");
    const parser2 = new RuleParser(unescapedTxt);
    parser2.parse();
    this.rules = [];
    this.insertTrigSet = /* @__PURE__ */ new Set();
    this.deleteTrigSet = /* @__PURE__ */ new Set();
    this.lmax = this.rmax = 0;
    this.errors = parser2.errors;
    if (this.errors.length > 0)
      return;
    if (justCheck)
      return;
    this.rules = parser2.convRules;
    this.index = newConvRulesIndex(this.rules);
    this.sideInsertMap = parser2.sideRules;
    for (const r of this.rules) {
      if (r.isForDelete) {
        this.deleteTrigSet.add(r.trigHintChar);
      } else {
        this.insertTrigSet.add(r.trigHintChar);
      }
      if (r.lBefore2AnchorLen > this.lmax)
        this.lmax = r.lBefore2AnchorLen;
      if (r.lAfterAnchorLen > this.rmax)
        this.rmax = r.lAfterAnchorLen;
    }
  }
  match(input, insChar, insPosBaseLineHead) {
    const leftMatch = input.slice(0, insPosBaseLineHead);
    const candidates = this.index.collectIdxsAlong(leftMatch + insChar);
    for (const idx of candidates.sort((a, b) => a - b)) {
      if (this.rules[idx].canConvert(input, insChar, insPosBaseLineHead)) {
        return this.rules[idx];
      }
    }
    return null;
  }
};
function newConvRulesIndex(rules) {
  const root = new TrieNode();
  for (let i = 0; i < rules.length; i++) {
    root.insert(rules[i], i);
  }
  return root;
}
var TrieNode = class {
  constructor() {
    this.next = /* @__PURE__ */ new Map();
    this.value = [];
  }
  isKeyStop() {
    return this.value.length > 0;
  }
  insert(rule, idx) {
    const key = rule.leftMatchPart();
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      const ch = key[i];
      if (node.next.has(ch)) {
        node = node.next.get(ch);
      } else {
        const newNode = new TrieNode();
        node.next.set(ch, newNode);
        node = newNode;
      }
    }
    node.value.push(idx);
  }
  collectIdxsAlong(key) {
    const idxs = [];
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      if (node.isKeyStop()) {
        idxs.push(...node.value);
      }
      node = node.next.get(key[i]);
      if (node === void 0) {
        break;
      }
    }
    if (node != void 0 && node.isKeyStop()) {
      idxs.push(...node.value);
    }
    return idxs;
  }
};

// src/ext_libertyzone.ts
var import_view = require("@codemirror/view");
function libertyZone(zonespotter) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(_) {
      this.decorations = import_view.Decoration.none;
      this.cleanTimer = -1;
    }
    get isTimerActive() {
      return this.cleanTimer >= 0;
    }
    tryRemoveTimer() {
      if (this.isTimerActive) {
        window.clearTimeout(this.cleanTimer);
        this.cleanTimer = -1;
      }
    }
    update(update) {
      const range = zonespotter(update);
      if (range === void 0 || update.state.doc.lineAt(range.from).from == range.from) {
        this.tryRemoveTimer();
        this.cleanTimer = window.setTimeout(() => {
          if (this.decorations.size) {
            this.decorations = import_view.Decoration.none;
          }
        }, 1e3);
        return;
      }
      this.decorations = import_view.Decoration.set(import_view.Decoration.widget({
        widget: new MarkWidget(15),
        side: 1
      }).range(range.from));
      this.tryRemoveTimer();
    }
  }, {
    decorations: (v) => v.decorations
  });
}
var MarkWidget = class extends import_view.WidgetType {
  constructor(lineHeight) {
    super();
    this.lineHeight = lineHeight;
  }
  toDOM() {
    const mark = document.createElement("span");
    mark.style.position = "relative";
    mark.style.top = `-${this.lineHeight}px`;
    mark.innerText = "\u2B50\uFE0F";
    const wrapper = document.createElement("div");
    wrapper.style.display = "inline-block";
    wrapper.style.position = "absolute";
    wrapper.append(mark);
    return wrapper;
  }
  ignoreEvent() {
    return false;
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_language2 = require("@codemirror/language");

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  constructor(config3 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config3.perNode;
    this.deserialize = config3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class {
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
var NodeSet = class {
  constructor(types) {
    this.types = types;
    for (let i = 0; i < types.length; i++)
      if (types[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add[0].id] = add[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class {
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  balance(config3 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config3.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class {
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  childString(index) {
    let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2);
  }
  childBefore(pos) {
    return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur = node.cursor(), result = [];
  if (!cur.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur.type.is(before);
      if (!cur.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(pos) {
    return this.child(1, pos, 2);
  }
  childBefore(pos) {
    return this.child(-1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  get name() {
    return this.type.name;
  }
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(pos) {
    return this.enterChild(1, pos, 2);
  }
  childBefore(pos) {
    return this.enterChild(-1, pos, -2);
  }
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next(enter = true) {
    return this.move(1, enter);
  }
  prev(enter = true) {
    return this.move(-1, enter);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache2 = this.bufferNode, result = null, depth = 0;
    if (cache2 && cache2.context == this.buffer) {
      scan:
        for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache2; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i);
      let type = types[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id: id2, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor.pos > minPos) {
      let { id: id2, start, end, size } = cursor;
      if (size > 4) {
        cursor.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base, i, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(total * 1.5 / 8);
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var NodeWeakMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(buffer, index, value) {
    let inner = this.map.get(buffer);
    if (!inner)
      this.map.set(buffer, inner = /* @__PURE__ */ new Map());
    inner.set(index, value);
  }
  getBuffer(buffer, index) {
    let inner = this.map.get(buffer);
    return inner && inner.get(index);
  }
  set(node, value) {
    if (node instanceof BufferNode)
      this.setBuffer(node.context.buffer, node.index, value);
    else if (node instanceof TreeNode)
      this.map.set(node.tree, value);
  }
  get(node) {
    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
  }
  cursorSet(cursor, value) {
    if (cursor.buffer)
      this.setBuffer(cursor.buffer.buffer, cursor.index, value);
    else
      this.map.set(cursor.tree, value);
  }
  cursorGet(cursor) {
    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
  }
};
var Parser = class {
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/lr/dist/index.js
var Stack = class {
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    var _a;
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord)
      this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base];
    } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur = this, top = this.buffer.length;
      if (top == 0 && cur.parent) {
        top = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
        if (start == end)
          return;
        if (cur.buffer[top - 2] >= start) {
          cur.buffer[top - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && this.buffer[index - 4] != 0) {
        let mustMove = false;
        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (end > this.pos || type <= parser2.maxNode) {
        this.pos = end;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser2.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index, start, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
    while (parent && base == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let { parser: parser2 } = this.p;
    let reduce = parser2.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  findForcedReduction() {
    let { parser: parser2 } = this.p, seen = [];
    let explore = (state, depth) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072))
          ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2)) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser2 } = stack.p;
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan:
    for (; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          let term = data[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low = 0, high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index = accEnd + mid + (mid << 1);
        let from = data[index], to = data[index + 1] || 65536;
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top = this.trees[last], index = this.index[last];
      if (index == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top.children[index];
      let start = this.start[last] + top.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2)
              index = this.putAction(pair(data, i + 2), token, end, index);
            break;
          }
        }
        if (data[i] == token)
          index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
};
var Parse = class {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks;
      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
      if (newStacks.length > 12)
        newStacks.splice(12, newStacks.length - 12);
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x) => x;
var ContextTracker = class {
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class extends Parser {
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  validAction(state, action) {
    return !!this.allActions(state, (a) => a == action ? true : null);
  }
  allActions(state, action) {
    let deflt = this.stateSlot(state, 4);
    let result = deflt ? action(deflt) : void 0;
    for (let i = this.stateSlot(state, 1); result == null; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      result = action(pair(this.data, i + 1));
    }
    return result;
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  configure(config3) {
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config3.props)
      copy.nodeSet = this.nodeSet.extend(...config3.props);
    if (config3.top) {
      let info = this.topRules[config3.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config3.top}`);
      copy.top = info;
    }
    if (config3.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config3.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config3.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config3.specializers.find((r) => r.from == s.external);
        if (!found)
          return s;
        let spec = Object.assign(Object.assign({}, s), { external: found.to });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config3.contextTracker)
      copy.context = config3.contextTracker;
    if (config3.dialect)
      copy.dialect = this.parseDialect(config3.dialect);
    if (config3.strict != null)
      copy.strict = config3.strict;
    if (config3.wrap)
      copy.wrappers = copy.wrappers.concat(config3.wrap);
    if (config3.bufferLength != null)
      copy.bufferLength = config3.bufferLength;
    return copy;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  }
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class {
  constructor(name2, set, base, modified) {
    this.name = name2;
    this.set = set;
    this.base = base;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base, mods) {
    if (!mods.length)
      return base;
    let exists = mods[0].instances.find((t2) => t2.base == base && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base.name, set, base, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base.set)
      if (!parent.modified.length)
        for (let config3 of configs)
          set.push(Modifier.get(parent, config3));
    return tag;
  }
};
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule2(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule2 = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule2.empty = new Rule2([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  comment,
  lineComment: t(comment),
  blockComment: t(comment),
  docComment: t(comment),
  name,
  variableName: t(name),
  typeName,
  tagName: t(typeName),
  propertyName,
  attributeName: t(propertyName),
  className: t(name),
  labelName: t(name),
  namespace: t(name),
  macroName: t(name),
  literal,
  string,
  docString: t(string),
  character: t(string),
  attributeValue: t(string),
  number,
  integer: t(number),
  float: t(number),
  bool: t(literal),
  regexp: t(literal),
  escape: t(literal),
  color: t(literal),
  url: t(literal),
  keyword,
  self: t(keyword),
  null: t(keyword),
  atom: t(keyword),
  unit: t(keyword),
  modifier: t(keyword),
  operatorKeyword: t(keyword),
  controlKeyword: t(keyword),
  definitionKeyword: t(keyword),
  moduleKeyword: t(keyword),
  operator,
  derefOperator: t(operator),
  arithmeticOperator: t(operator),
  logicOperator: t(operator),
  bitwiseOperator: t(operator),
  compareOperator: t(operator),
  updateOperator: t(operator),
  definitionOperator: t(operator),
  typeOperator: t(operator),
  controlOperator: t(operator),
  punctuation,
  separator: t(punctuation),
  bracket,
  angleBracket: t(bracket),
  squareBracket: t(bracket),
  paren: t(bracket),
  brace: t(bracket),
  content,
  heading,
  heading1: t(heading),
  heading2: t(heading),
  heading3: t(heading),
  heading4: t(heading),
  heading5: t(heading),
  heading6: t(heading),
  contentSeparator: t(content),
  list: t(content),
  quote: t(content),
  emphasis: t(content),
  strong: t(content),
  link: t(content),
  monospace: t(content),
  strikethrough: t(content),
  inserted: t(),
  deleted: t(),
  changed: t(),
  invalid: t(),
  meta,
  documentMeta: t(meta),
  annotation: t(meta),
  processingInstruction: t(meta),
  definition: Tag.defineModifier("definition"),
  constant: Tag.defineModifier("constant"),
  function: Tag.defineModifier("function"),
  standard: Tag.defineModifier("standard"),
  local: Tag.defineModifier("local"),
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@lezer/python/dist/index.js
var printKeyword = 1;
var indent = 194;
var dedent = 195;
var newline$1 = 196;
var blankLineStart = 197;
var newlineBracketed = 198;
var eof = 199;
var stringContent = 200;
var Escape = 2;
var replacementStart = 3;
var stringEnd = 201;
var ParenL = 24;
var ParenthesizedExpression = 25;
var TupleExpression = 49;
var ComprehensionExpression = 50;
var BracketL = 55;
var ArrayExpression = 56;
var ArrayComprehensionExpression = 57;
var BraceL = 59;
var DictionaryExpression = 60;
var DictionaryComprehensionExpression = 61;
var SetExpression = 62;
var SetComprehensionExpression = 63;
var ArgList = 65;
var subscript = 238;
var String$1 = 71;
var stringStart = 241;
var stringStartD = 242;
var stringStartL = 243;
var stringStartLD = 244;
var stringStartR = 245;
var stringStartRD = 246;
var stringStartRL = 247;
var stringStartRLD = 248;
var FormatString = 72;
var stringStartF = 249;
var stringStartFD = 250;
var stringStartFL = 251;
var stringStartFLD = 252;
var stringStartFR = 253;
var stringStartFRD = 254;
var stringStartFRL = 255;
var stringStartFRLD = 256;
var FormatReplacement = 73;
var nestedFormatReplacement = 77;
var importList = 263;
var TypeParamList = 112;
var ParamList = 130;
var SequencePattern = 151;
var MappingPattern = 152;
var PatternArgList = 155;
var newline = 10;
var carriageReturn = 13;
var space = 32;
var tab = 9;
var hash = 35;
var parenOpen = 40;
var dot = 46;
var braceOpen = 123;
var braceClose = 125;
var singleQuote = 39;
var doubleQuote = 34;
var backslash = 92;
var letter_o = 111;
var letter_x = 120;
var letter_N = 78;
var letter_u = 117;
var letter_U = 85;
var bracketed = /* @__PURE__ */ new Set([
  ParenthesizedExpression,
  TupleExpression,
  ComprehensionExpression,
  importList,
  ArgList,
  ParamList,
  ArrayExpression,
  ArrayComprehensionExpression,
  subscript,
  SetExpression,
  SetComprehensionExpression,
  FormatString,
  FormatReplacement,
  nestedFormatReplacement,
  DictionaryExpression,
  DictionaryComprehensionExpression,
  SequencePattern,
  MappingPattern,
  PatternArgList,
  TypeParamList
]);
function isLineBreak(ch) {
  return ch == newline || ch == carriageReturn;
}
function isHex(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
var newlines = new ExternalTokenizer((input, stack) => {
  let prev;
  if (input.next < 0) {
    input.acceptToken(eof);
  } else if (stack.context.flags & cx_Bracketed) {
    if (isLineBreak(input.next))
      input.acceptToken(newlineBracketed, 1);
  } else if (((prev = input.peek(-1)) < 0 || isLineBreak(prev)) && stack.canShift(blankLineStart)) {
    let spaces = 0;
    while (input.next == space || input.next == tab) {
      input.advance();
      spaces++;
    }
    if (input.next == newline || input.next == carriageReturn || input.next == hash)
      input.acceptToken(blankLineStart, -spaces);
  } else if (isLineBreak(input.next)) {
    input.acceptToken(newline$1, 1);
  }
}, { contextual: true });
var indentation = new ExternalTokenizer((input, stack) => {
  let context = stack.context;
  if (context.flags)
    return;
  let prev = input.peek(-1);
  if (prev == newline || prev == carriageReturn) {
    let depth = 0, chars = 0;
    for (; ; ) {
      if (input.next == space)
        depth++;
      else if (input.next == tab)
        depth += 8 - depth % 8;
      else
        break;
      input.advance();
      chars++;
    }
    if (depth != context.indent && input.next != newline && input.next != carriageReturn && input.next != hash) {
      if (depth < context.indent)
        input.acceptToken(dedent, -chars);
      else
        input.acceptToken(indent);
    }
  }
});
var cx_Bracketed = 1;
var cx_String = 2;
var cx_DoubleQuote = 4;
var cx_Long = 8;
var cx_Raw = 16;
var cx_Format = 32;
function Context(parent, indent2, flags) {
  this.parent = parent;
  this.indent = indent2;
  this.flags = flags;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + indent2 + (indent2 << 4) + flags + (flags << 6);
}
var topIndent = new Context(null, 0, 0);
function countIndent(space2) {
  let depth = 0;
  for (let i = 0; i < space2.length; i++)
    depth += space2.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
  return depth;
}
var stringFlags = new Map([
  [stringStart, 0],
  [stringStartD, cx_DoubleQuote],
  [stringStartL, cx_Long],
  [stringStartLD, cx_Long | cx_DoubleQuote],
  [stringStartR, cx_Raw],
  [stringStartRD, cx_Raw | cx_DoubleQuote],
  [stringStartRL, cx_Raw | cx_Long],
  [stringStartRLD, cx_Raw | cx_Long | cx_DoubleQuote],
  [stringStartF, cx_Format],
  [stringStartFD, cx_Format | cx_DoubleQuote],
  [stringStartFL, cx_Format | cx_Long],
  [stringStartFLD, cx_Format | cx_Long | cx_DoubleQuote],
  [stringStartFR, cx_Format | cx_Raw],
  [stringStartFRD, cx_Format | cx_Raw | cx_DoubleQuote],
  [stringStartFRL, cx_Format | cx_Raw | cx_Long],
  [stringStartFRLD, cx_Format | cx_Raw | cx_Long | cx_DoubleQuote]
].map(([term, flags]) => [term, flags | cx_String]));
var trackIndent = new ContextTracker({
  start: topIndent,
  reduce(context, term, _, input) {
    if (context.flags & cx_Bracketed && bracketed.has(term) || (term == String$1 || term == FormatString) && context.flags & cx_String)
      return context.parent;
    return context;
  },
  shift(context, term, stack, input) {
    if (term == indent)
      return new Context(context, countIndent(input.read(input.pos, stack.pos)), 0);
    if (term == dedent)
      return context.parent;
    if (term == ParenL || term == BracketL || term == BraceL || term == replacementStart)
      return new Context(context, 0, cx_Bracketed);
    if (stringFlags.has(term))
      return new Context(context, 0, stringFlags.get(term) | context.flags & cx_Bracketed);
    return context;
  },
  hash(context) {
    return context.hash;
  }
});
var legacyPrint = new ExternalTokenizer((input) => {
  for (let i = 0; i < 5; i++) {
    if (input.next != "print".charCodeAt(i))
      return;
    input.advance();
  }
  if (/\w/.test(String.fromCharCode(input.next)))
    return;
  for (let off = 0; ; off++) {
    let next = input.peek(off);
    if (next == space || next == tab)
      continue;
    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
      input.acceptToken(printKeyword);
    return;
  }
});
var strings = new ExternalTokenizer((input, stack) => {
  let { flags } = stack.context;
  let quote = flags & cx_DoubleQuote ? doubleQuote : singleQuote;
  let long = (flags & cx_Long) > 0;
  let escapes = !(flags & cx_Raw);
  let format = (flags & cx_Format) > 0;
  let start = input.pos;
  for (; ; ) {
    if (input.next < 0) {
      break;
    } else if (format && input.next == braceOpen) {
      if (input.peek(1) == braceOpen) {
        input.advance(2);
      } else {
        if (input.pos == start) {
          input.acceptToken(replacementStart, 1);
          return;
        }
        break;
      }
    } else if (escapes && input.next == backslash) {
      if (input.pos == start) {
        input.advance();
        let escaped = input.next;
        if (escaped >= 0) {
          input.advance();
          skipEscape(input, escaped);
        }
        input.acceptToken(Escape);
        return;
      }
      break;
    } else if (input.next == quote && (!long || input.peek(1) == quote && input.peek(2) == quote)) {
      if (input.pos == start) {
        input.acceptToken(stringEnd, long ? 3 : 1);
        return;
      }
      break;
    } else if (input.next == newline) {
      if (long) {
        input.advance();
      } else if (input.pos == start) {
        input.acceptToken(stringEnd);
        return;
      }
      break;
    } else {
      input.advance();
    }
  }
  if (input.pos > start)
    input.acceptToken(stringContent);
});
function skipEscape(input, ch) {
  if (ch == letter_o) {
    for (let i = 0; i < 2 && input.next >= 48 && input.next <= 55; i++)
      input.advance();
  } else if (ch == letter_x) {
    for (let i = 0; i < 2 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_u) {
    for (let i = 0; i < 4 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_U) {
    for (let i = 0; i < 8 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_N) {
    if (input.next == braceOpen) {
      input.advance();
      while (input.next >= 0 && input.next != braceClose && input.next != singleQuote && input.next != doubleQuote && input.next != newline)
        input.advance();
      if (input.next == braceClose)
        input.advance();
    }
  }
}
var pythonHighlighting = styleTags({
  'async "*" "**" FormatConversion FormatSpec': tags.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": tags.controlKeyword,
  "in not and or is del": tags.operatorKeyword,
  "from def class global nonlocal lambda": tags.definitionKeyword,
  import: tags.moduleKeyword,
  "with as print": tags.keyword,
  Boolean: tags.bool,
  None: tags.null,
  VariableName: tags.variableName,
  "CallExpression/VariableName": tags.function(tags.variableName),
  "FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
  "ClassDefinition/VariableName": tags.definition(tags.className),
  PropertyName: tags.propertyName,
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  Comment: tags.lineComment,
  Number: tags.number,
  String: tags.string,
  FormatString: tags.special(tags.string),
  Escape: tags.escape,
  UpdateOp: tags.updateOperator,
  "ArithOp!": tags.arithmeticOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  AssignOp: tags.definitionOperator,
  Ellipsis: tags.punctuation,
  At: tags.meta,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  ".": tags.derefOperator,
  ", ;": tags.separator
});
var spec_identifier = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 };
var parser = LRParser.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5QQdO'#DoOOQS,5:Y,5:YO5eQdO'#HdOOQS,5:],5:]O5rQ!fO,5:]O5wQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8gQdO,59bO8lQdO,59bO8sQdO,59jO8zQdO'#HTO:QQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:iQdO,59aO'vQdO,59aO:wQdO,59aOOQS,59y,59yO:|QdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;[QdO,5:QO;aQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;rQdO,5:UO;wQdO,5:WOOOW'#Fy'#FyO;|OWO,5:aOOQS,5:a,5:aO<XQdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<iOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<wQtO,5:iO?iQtO,5=`O@SQ#xO,5=`O@sQtO,5=`OOQS,5:},5:}OA[QeO'#GWOBnQdO,5;^OOQV,5=^,5=^OByQtO'#IPOChQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCpQtO,59]OEwQtO,59iOFbQdO'#HVOFmQdO'#HVO1XQdO'#HVOFxQdO'#DTOGQQdO,59mOGVQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGtQdO'#GPOHUQdO,58|OHUQdO,58|O*xQdO,5:oOHdQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHwQdO,5;OOIYQdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOInQtO,5;QOI|QdO,5;QOJRQdO'#IQOOQS,5;T,5;TOJaQdO'#H|OOQS,5;W,5;WOJrQdO,5;YO4iQdO,5;`O4iQdO,5;cOJzQtO'#ITO'vQdO'#ITOKUQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOKZQeO'#EuOLgQgO,5;fO!!hQdO'#IUO4iQdO,5;jO!!sQdO,5;lO!!{QdO,5;qO!#WQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#_OSO,5=[P!#dOdO,5=[O!&XQtO1G.jO!&`QtO1G.jO!)PQtO1G.jO!)ZQtO1G.jO!+tQtO1G.jO!,XQtO1G.jO!,lQdO'#HcO!,zQtO'#GuO0rQdO'#HcO!-UQdO'#HbOOQS,5:Z,5:ZO!-^QdO,5:ZO!-cQdO'#HeO!-nQdO'#HeO!.RQdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/RQtO1G.|O!/YQtO1G.|O1lQdO1G.|O!/uQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!/|QdO1G/eO!0^QdO1G/eO!0fQdO1G/fO'vQdO'#H[O!0kQdO'#H[O!0pQtO1G.{O!1QQdO,59iO!2WQdO,5=zO!2hQdO,5=zO!2pQdO1G/mO!2uQtO1G/mOOQS1G/l1G/lO!3VQdO,5=uO!3|QdO,5=uO0rQdO1G/qO!4kQdO1G/sO!4pQtO1G/sO!5QQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5bQdO'#HxO0rQdO'#HxO!5sQdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6RQ#xO1G2zO!6rQtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7ZQtO,5>kOOQS1G1`1G1`O!7xQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!7}QdO'#FrO!8YQdO,59oO!8bQdO1G/XO!8lQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9]QdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9nQdO1G.hOOQS1G0Z1G0ZO!9|QdO,5=wO!:^QdO,5=wO0rQdO1G0jO0rQdO1G0jO!:oQdO,5>jO!;QQdO,5>jO1XQdO,5>jO!;cQdO,5>iOOQS-E:R-E:RO!;hQdO1G0lO!;sQdO1G0lO!;xQdO,5>lO!<WQdO,5>lO!<fQdO,5>hO!<|QdO,5>hO!=_QdO'#EpO0rQdO1G0tO!=jQdO1G0tO!=oQgO1G0zO!AmQgO1G0}O!EhQdO,5>oO!ErQdO,5>oO!EzQtO,5>oO0rQdO1G1PO!FUQdO1G1PO4iQdO1G1UO!!sQdO1G1WOOQV,5;a,5;aO!FZQfO,5;aO!F`QgO1G1QO!JaQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JqQdO,5>pO!KOQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KWQdO'#FSO!KiQ!fO1G1WO!KqQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!KvQdO1G1]O!LOQdO'#F^OOQV1G1b1G1bO!#WQtO1G1bPOOO1G2v1G2vP!LTOSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LYQdO,5=|O!LmQdO,5=|OOQS1G/u1G/uO!LuQdO,5>PO!MVQdO,5>PO!M_QdO,5>PO!MrQdO,5>PO!NSQdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8bQdO7+$pO# uQdO1G.|O# |QdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!TQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!eQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!jQdO7+%PO#!rQdO7+%QO#!wQdO1G3fOOQS7+%X7+%XO##XQdO1G3fO##aQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##fQdO1G3aOOQS-E9q-E9qO#$]QdO7+%]OOQS7+%_7+%_O#$kQdO1G3aO#%YQdO7+%_O#%_QdO1G3gO#%oQdO1G3gO#%wQdO7+%]O#%|QdO,5>dO#&gQdO,5>dO#&gQdO,5>dOOQS'#Dx'#DxO#&xO&jO'#DzO#'TO`O'#HyOOOW1G3}1G3}O#'YQdO1G3}O#'bQdO1G3}O#'mQ#xO7+(fO#(^QtO1G2UP#(wQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)UQdO,5=`O#)oQdO,5=`O#*QQtO,5<aO#*eQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#*uQdO7+&UO#+TQdO,5<nO#+iQdO1G4UOOQS-E:Q-E:QO#+zQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,]QdO7+&WOOQS,5<p,5<pO#,hQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#,vQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-^QdO'#EqO#-iQdO'#IRO#-qQdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#-vQgO7+&fO!JdQdO'#GXO4iQdO7+&fO4iQdO7+&iO#1tQtO,5<tO'vQdO,5<tO#2OQdO1G4ZOOQS-E:W-E:WO#2YQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KiQ!fO7+&rO!KqQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2bQdO,5<uO!JdQdO,5<uOOQV7+&l7+&lO#2mQgO7+&lO#6hQdO,5<vO#6sQdO1G4[OOQS-E:Y-E:YO#7QQdO1G4[O#7YQdO'#IWO#7hQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#7sQdO'#IVOOQS,5;n,5;nO#7{QdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8QQfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8VQdO1G3iOOQS,5<c,5<cO#8eQdO1G3hOOQS-E9u-E9uO#8xQdO,5<dO#9TQdO,5<dO#9hQdO1G3kOOQS-E9v-E9vO#9xQdO1G3kO#:QQdO1G3kO#:bQdO1G3kO#9xQdO1G3kOOQS<<H[<<H[O#:mQtO1G1zOOQS<<Hk<<HkP#:zQdO'#FtO8sQdO1G3bO#;XQdO1G3bO#;^QdO<<HkOOQS<<Hl<<HlO#;nQdO7+)QOOQS<<Hs<<HsO#<OQtO1G1yP#<oQdO'#FsO#<|QdO7+)RO#=^QdO7+)RO#=fQdO<<HwO#=kQdO7+({OOQS<<Hy<<HyO#>bQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>gQdO1G4OOOQS-E9y-E9yO#?QQdO1G4OO<XQdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?cO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?nQdO7+)iO#?vQdO1G2zO#@aQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#@rQdO7+)pO#ATQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#AfQdO,5>mO#AtQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#A|QtO1G2`P#BWQdO'#GYO#B_QdO7+)uO#BiQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KiQ!fO<<J^O#FdQgO7+&gOOQV<<JW<<JWO#FnQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JiQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#JtQdO7+)vO#KRQdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KZQdO,5>rOOQS,5>r,5>rO#KfQdO,5>qO#KwQdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LPQdO1G1dOOQS7+)T7+)TP#LUQdO'#FwO#LfQdO1G2OO#LyQdO1G2OO#MZQdO1G2OP#MfQdO'#FxO#MsQdO7+)VO#NTQdO7+)VO#NTQdO7+)VO#N]QdO7+)VO#NmQdO7+(|O8sQdO7+(|OOQSAN>VAN>VO$ WQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$ hQtO1G1|P$ rQdO'#FvOOQS1G2R1G2RP$!PQdO'#F{O$!^QdO7+)jO$!wQdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#VQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$#pQdO<<M[OOQS,5<q,5<qO$$RQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$aQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$([QdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$(iQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$(zQfO7+'OO$)VQdO'#F_O$*^QdO7+'jO$*nQdO7+'jOOQS7+'j7+'jO$*yQdO<<LqO$+ZQdO<<LqO$+ZQdO<<LqO$+cQdO'#H^OOQS<<Lh<<LhO$+mQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,WQdO1G4RO$,`QdO1G4RP!=_QdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$,kQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-_QtO'#FaOOQS'#Fc'#FcO$-oQdO'#FbO$.aQdO'#FbOOQS'#Fb'#FbO$.fQdO'#IYO$)VQdO'#FiO$)VQdO'#FiO$.}QdO'#FjO$)VQdO'#FkO$/UQdO'#IZOOQS'#IZ'#IZO$/sQdO,5;yOOQS<<KU<<KUO$/{QdO<<KUO$0]QdOANB]O$0mQdOANB]O$0uQdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1`QdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$1wQdO7+)mOOQVLD*wLD*wOOQVANARANARO5rQ!fO'#GaO$2PQtO,5<SO$)VQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$2qQdO,5;|O$2vQdO,5;|OOQS'#Fg'#FgO$)VQdO'#G`O$3hQdO,5<QO$4SQdO,5>tO$4dQdO,5>tO1XQdO,5<PO$4uQdO,5<TO$4zQdO,5<TO$)VQdO'#I[O$5PQdO'#I[O$5UQdO,5<UOOQS,5<V,5<VO'vQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5ZQdOG27wO$5kQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$5pQtO'#FaO$5wQdO'#I]O$6VQdO'#I]O$6_QdO,5<XOOQS1G1h1G1hO$6dQdO1G1hO$6iQdO,5<zOOQS-E:^-E:^O$7TQdO,5=OO$7lQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$7|QdO,5>vO$)VQdO,5>vOOQS1G1p1G1pO$8[QtO,5<[OOQU7+'P7+'PO$+cQdO1G/iO$)VQdO,5<YO$8cQdO,5>wO$8jQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)VQdO'#GdO$8rQdO1G4bO$8|QdO1G4bO$9UQdO1G4bOOQS7+%T7+%TO$9dQdO1G1tO$9rQtO'#FaO$9yQdO,5<}OOQS,5<},5<}O$:XQdO1G4cOOQS-E:a-E:aO$)VQdO,5<|O$:`QdO,5<|O$:eQdO7+)|OOQS-E:`-E:`O$:oQdO7+)|O$)VQdO,5<ZP$)VQdO'#GcO$:wQdO1G2hO$)VQdO1G2hP$;VQdO'#GbO$;^QdO<<MhO$;hQdO1G1uO$;vQdO7+(SO8sQdO'#C}O8sQdO,59bO8sQdO,59bO8sQdO,59bO$<UQtO,5=`O8sQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<iQdO'#GOO'vQdO'#GtO$<vQdO,59bO$<{QdO,59bO$=SQdO,59mO$=XQdO1G/UO1sQdO'#DRO8sQdO,59j",
  stateData: "$=r~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PE`O%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO~OS'iO%['hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#lO%kWi~P!#lOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&gO%mWi%nWi~P!&gOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)eOVWi_Wi%qWi%rWi%sWi~P!)eO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.WOlji~P!.WOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/aOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PE`OV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!N_Olji~P!N_OV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/aOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/aO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$,yO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)cOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/aOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)VOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$,yOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)VOz/zO#[/OO%j.yO!['Oa~O{$da~P%SOg'Pa~P$)VOz0SOg'Pa~Oa0UO!['Oi~P$)cOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$,yO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)VO{0^O~Oa0UO!['Oq~P$)cOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)cOa0UO!['Oy~P$)cO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/aO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=l'QPPPPPP'RP'Z*s+]+v,b,}-kP.YP'Z.y.y'ZPPP'Z2cPPPPPP2c5VPP5VP7g7p=xPP={>m>pPP'Z'ZPP?PPP'Z'ZPP'Z'Z'Z'Z'Z?T?}'ZP@QP@WD_G{HPPHSH^Hb'ZPPPHeHn'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHtIQIYPIaIgPIaPIaIaPPPIaPKuPLOLYL`KuPIaLiPIaPLpLvPLzM`M}NhLzLzNnN{LzLzLzLz! a! g! j! o! r! |!!S!!`!!r!!x!#S!#Y!#v!#|!$S!$^!$d!$j!$|!%W!%^!%d!%n!%t!%z!&Q!&W!&^!&h!&n!&x!'O!'X!'_!'n!'v!(Q!(XPPPPPPPPPPP!(_!(b!(h!(q!({!)WPPPPPPPPPPPP!-z!/`!3`!6pPP!6x!7X!7b!8Z!8Q!8d!8j!8m!8p!8s!8{!9lPPPPPPPPPPPPPPPPP!9o!9s!9yP!:_!:c!:o!:x!;U!;l!;o!;r!;x!<O!<U!<XP!<a!<j!=f!=i]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r}!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!P!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!R!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!T!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!V!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!X!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g!]!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&cVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/Z/s0c0d0e0f0h0i0j0k0n0r%mXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s![!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aR,^*RX#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&bQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QQ/q/VR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uR.S-fhUOn#d#g$j%|&_'w(p(r)t,P%S!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!]!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v/q0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: "\u26A0 print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: trackIndent,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [pythonHighlighting],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [legacyPrint, indentation, newlines, strings, 0, 1, 2, 3, 4],
  topRules: { "Script": [0, 5] },
  specialized: [{ term: 221, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 7652
});

// node_modules/@codemirror/lang-python/dist/index.js
var import_language = require("@codemirror/language");
var import_autocomplete = require("@codemirror/autocomplete");
var cache = /* @__PURE__ */ new NodeWeakMap();
var ScopeNodes = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function defID(type) {
  return (node, def, outer) => {
    if (outer)
      return false;
    let id2 = node.node.getChild("VariableName");
    if (id2)
      def(id2, type);
    return true;
  };
}
var gatherCompletions = {
  FunctionDefinition: /* @__PURE__ */ defID("function"),
  ClassDefinition: /* @__PURE__ */ defID("class"),
  ForStatement(node, def, outer) {
    if (outer)
      for (let child = node.node.firstChild; child; child = child.nextSibling) {
        if (child.name == "VariableName")
          def(child, "variable");
        else if (child.name == "in")
          break;
      }
  },
  ImportStatement(_node, def) {
    var _a, _b;
    let { node } = _node;
    let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == "from";
    for (let ch = node.getChild("import"); ch; ch = ch.nextSibling) {
      if (ch.name == "VariableName" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != "as")
        def(ch, isFrom ? "variable" : "namespace");
    }
  },
  AssignStatement(node, def) {
    for (let child = node.node.firstChild; child; child = child.nextSibling) {
      if (child.name == "VariableName")
        def(child, "variable");
      else if (child.name == ":" || child.name == "AssignOp")
        break;
    }
  },
  ParamList(node, def) {
    for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {
      if (child.name == "VariableName" && (!prev || !/\*|AssignOp/.test(prev.name)))
        def(child, "variable");
      prev = child;
    }
  },
  CapturePattern: /* @__PURE__ */ defID("variable"),
  AsPattern: /* @__PURE__ */ defID("variable"),
  __proto__: null
};
function getScope(doc, node) {
  let cached = cache.get(node);
  if (cached)
    return cached;
  let completions = [], top = true;
  function def(node2, type) {
    let name2 = doc.sliceString(node2.from, node2.to);
    completions.push({ label: name2, type });
  }
  node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
    if (node2.name) {
      let gather = gatherCompletions[node2.name];
      if (gather && gather(node2, def, top) || !top && ScopeNodes.has(node2.name))
        return false;
      top = false;
    } else if (node2.to - node2.from > 8192) {
      for (let c of getScope(doc, node2.node))
        completions.push(c);
      return false;
    }
  });
  cache.set(node, completions);
  return completions;
}
var Identifier = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
var dontComplete = ["String", "FormatString", "Comment", "PropertyName"];
function localCompletionSource(context) {
  let inner = (0, import_language.syntaxTree)(context.state).resolveInner(context.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context.explicit)
    return null;
  let options = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options = options.concat(getScope(context.state.doc, pos));
  }
  return {
    options,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  };
}
var globals = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((n) => ({ label: n, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((n) => ({ label: n, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((n) => ({ label: n, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((n) => ({ label: n, type: "function" })));
var snippets = [
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${}:\n	\n", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
];
var globalCompletion = /* @__PURE__ */ (0, import_autocomplete.ifNotIn)(dontComplete, /* @__PURE__ */ (0, import_autocomplete.completeFromList)(/* @__PURE__ */ globals.concat(snippets)));
function innerBody(context) {
  let { node, pos } = context;
  let lineIndent = context.lineIndent(pos, -1);
  let found = null;
  for (; ; ) {
    let before = node.childBefore(pos);
    if (!before) {
      break;
    } else if (before.name == "Comment") {
      pos = before.from;
    } else if (before.name == "Body") {
      if (context.baseIndentFor(before) + context.unit <= lineIndent)
        found = before;
      node = before;
    } else if (before.type.is("Statement")) {
      node = before;
    } else {
      break;
    }
  }
  return found;
}
function indentBody(context, node) {
  let base = context.baseIndentFor(node);
  let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
  if (/^\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base)
    return null;
  if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
    return null;
  return base + context.unit;
}
var pythonLanguage = /* @__PURE__ */ import_language.LRLanguage.define({
  name: "python",
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language.indentNodeProp.add({
        Body: (context) => {
          var _a;
          let inner = innerBody(context);
          return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();
        },
        IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        "ForStatement WhileStatement": (cx) => /^\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        TryStatement: (cx) => /^\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "]" }),
        "String FormatString": () => null,
        Script: (context) => {
          var _a;
          let inner = innerBody(context);
          return (_a = inner && indentBody(context, inner)) !== null && _a !== void 0 ? _a : context.continue();
        }
      }),
      /* @__PURE__ */ import_language.foldNodeProp.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": import_language.foldInside,
        Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function python() {
  return new import_language.LanguageSupport(pythonLanguage, [
    pythonLanguage.data.of({ autocomplete: localCompletionSource }),
    pythonLanguage.data.of({ autocomplete: globalCompletion })
  ]);
}

// src/settings.ts
var config2 = {
  name: "obsidian",
  dark: false,
  background: "var(--background-primary)",
  foreground: "var(--text-normal)",
  selection: "var(--text-selection)",
  cursor: "var(--text-normal)",
  activeLine: "var(--background-primary)",
  string: "var(--text-accent)",
  constant: "var(--text-accent-hover)",
  comment: "var(--text-faint)",
  invalid: "var(--text-error)"
};
var obsidianHighlightStyle = import_language2.HighlightStyle.define([
  { tag: [tags.processingInstruction, tags.string, tags.inserted, tags.special(tags.string)], color: config2.string },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: config2.constant },
  { tag: tags.comment, color: config2.comment },
  { tag: tags.invalid, color: config2.invalid }
]);
var obsidianTheme = import_view2.EditorView.theme({
  "&": {
    color: config2.foreground,
    backgroundColor: config2.background
  },
  ".cm-content": { caretColor: config2.cursor },
  "&.cm-focused .cm-cursor": { borderLeftColor: config2.cursor },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, & ::selection": { backgroundColor: config2.selection },
  ".cm-activeLine": { backgroundColor: config2.activeLine },
  ".cm-activeLineGutter": { backgroundColor: config2.background },
  ".cm-selectionMatch": { backgroundColor: config2.selection },
  ".cm-gutters": {
    backgroundColor: config2.background,
    color: config2.comment,
    borderRight: "1px solid var(--background-modifier-border)"
  },
  ".cm-lineNumbers, .cm-gutterElement": { color: "inherit" }
});
var BaseProfileName = "global";
var ProfileSwitch = import_state.Annotation.define();
var DEFAULT_SETTINGS = {
  debug: false,
  convertRules: DEFAULT_RULES,
  zoneIndicatorOn: false,
  autoFormatOn: true,
  profiles: [
    { title: BaseProfileName, content: DEFAULT_RULES }
  ],
  activeProfile: BaseProfileName
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.editorState = {
      selectedProfileName: BaseProfileName,
      selectedProfileEl: void 0,
      baseProfileEl: void 0,
      profilesMap: new Map(plugin.settings.profiles.map((p) => {
        return [p.title, p.content];
      })),
      editedProfile: /* @__PURE__ */ new Set()
    };
  }
  hide() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.ruleEditor) == null ? void 0 : _a.destroy();
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = this.editorState;
      if (set.size > 0) {
        const newProfiles = [];
        for (const [key, value] of map) {
          newProfiles.push({ title: key, content: value });
        }
        this.plugin.settings.profiles = newProfiles;
        log("setting: save profiles");
        yield this.plugin.saveSettings();
      }
      const activeProfile = this.plugin.settings.activeProfile;
      if (target != activeProfile || set.has(BaseProfileName) || set.has(activeProfile)) {
        const newRule = target === BaseProfileName ? map.get(BaseProfileName) : map.get(BaseProfileName) + "\n" + map.get(target);
        yield this.plugin.configureProfile(target, newRule);
      }
    });
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Typing Transformer Settings" });
    new import_obsidian.Setting(containerEl).setName("Debug Log").setDesc("Enable debug log to console.").addToggle(
      (comp) => comp.setValue(plugin.settings.debug).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleDebugLog();
      }))
    );
    new import_obsidian.Setting(containerEl).setName("Auto Format").setDesc("Enable the auto insertion of spaces.").addToggle(
      (comp) => comp.setValue(plugin.settings.autoFormatOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleAutoFormat();
      }))
    );
    new import_obsidian.Setting(containerEl).setName("Zone Indicator").setDesc("Enable indication of a zone's start point with '\u2B50\uFE0F'").addToggle(
      (comp) => comp.setValue(plugin.settings.zoneIndicatorOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleIndicator();
      }))
    );
    this.ruleEditor = createRuleEditorInContainer(containerEl, plugin, this.editorState);
  }
};
function createRuleEditorInContainer(container, plugin, state) {
  const fragment = document.createDocumentFragment();
  fragment.createEl("span", { text: "Enter conversion, selection, and deletion rules here. NOTES:" });
  const ol = fragment.createEl("ol");
  ol.createEl("li", { text: "Each line is one rule. Rules that come first have higher priority." });
  ol.createEl("li", { text: 'Lines starting with "#" are treated as comments and ignored. Inline comments are also allowed' });
  ol.createEl("li", { text: "Certain characters ' | \\ must be escaped with backslashes \\." });
  ol.createEl("li", { text: "Whatever tab you are on when the plugin settings tab quits will be the profile that is chosen" });
  ol.createEl("li", { text: "The 'global' profile will always be active" });
  const convertRulesSetting = new import_obsidian.Setting(container).setName("Rules").setDesc(fragment).setClass("rules-text-area");
  const profilesContainer = convertRulesSetting.controlEl.createDiv("rules-profiles");
  const customCSSWrapper = convertRulesSetting.controlEl.createDiv("rules-editor-wrapper");
  const rulesFooter = convertRulesSetting.controlEl.createDiv("rules-footer");
  const validity = rulesFooter.createDiv("rules-editor-validity");
  const validityIndicator = new import_obsidian.ExtraButtonComponent(validity);
  validityIndicator.setIcon("checkmark").extraSettingsEl.addClass("rules-editor-validity-indicator");
  const validityText = validity.createDiv("rules-editor-validity-text");
  validityText.classList.add("setting-item-description", "rules-editor-validity-txt");
  function resetValidityIndicator() {
    validityIndicator.setIcon("");
    validityIndicator.extraSettingsEl.removeClasses(["invalid", "valid"]);
    validityText.setText("");
  }
  function tryResetValidityIndicator() {
    return __async(this, null, function* () {
      if (validityIndicator.extraSettingsEl.hasClass("invalid")) {
        return new Promise((resolve, _reject) => {
          new ConfirmationModal(
            app,
            "Are you sure you want to discard changes?",
            (ans) => __async(this, null, function* () {
              if (ans)
                resetValidityIndicator();
              resolve(ans);
            })
          ).open();
        });
      } else {
        resetValidityIndicator();
        return new Promise((resolve, _reject) => resolve(true));
      }
    });
  }
  function updateValidityIndicator(success, errs) {
    validityIndicator.setIcon(success ? "checkmark" : "cross");
    validityIndicator.extraSettingsEl.removeClass(success ? "invalid" : "valid");
    validityIndicator.extraSettingsEl.addClass(success ? "valid" : "invalid");
    const fragment2 = document.createDocumentFragment();
    for (const err of errs) {
      fragment2.createEl("div", { text: err });
    }
    validityText.setText(success ? "Saved" : fragment2);
  }
  const extensions = [
    obsidianTheme,
    (0, import_view2.lineNumbers)(),
    import_view2.EditorView.lineWrapping,
    python(),
    (0, import_language2.syntaxHighlighting)(obsidianHighlightStyle),
    import_view2.EditorView.updateListener.of((v) => __async(this, null, function* () {
      if (v.docChanged) {
        if (v.transactions.reduce((swtich, tr) => swtich || tr.annotation(ProfileSwitch), false)) {
          return;
        }
        const value = v.state.doc.toString();
        yield feedRules(value);
      }
    }))
  ];
  const feedRules = (newRule) => __async(this, null, function* () {
    const errs = plugin.checkRules(newRule);
    if (errs.length != 0) {
      updateValidityIndicator(false, errs);
    } else {
      updateValidityIndicator(true, []);
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = state;
      map.set(target, newRule);
      set.add(target);
    }
  });
  const setCMEditorContent = (text) => {
    convertRulesEditor.dispatch({
      changes: { from: 0, to: convertRulesEditor.state.doc.length, insert: text },
      annotations: ProfileSwitch.of(true)
    });
  };
  const convertRulesEditor = new import_view2.EditorView({
    state: import_state.EditorState.create({ doc: plugin.settings.convertRules, extensions })
  });
  customCSSWrapper.appendChild(convertRulesEditor.dom);
  const buttonsDiv = rulesFooter.createDiv("rules-editor-buttons");
  const reset = new import_obsidian.ButtonComponent(buttonsDiv);
  reset.setIcon("switch").setTooltip("Reset to default rules").onClick(() => __async(this, null, function* () {
    convertRulesEditor.setState(import_state.EditorState.create({ doc: DEFAULT_RULES, extensions }));
    yield feedRules(DEFAULT_RULES);
  }));
  const onProfileClick = (name2, el) => __async(this, null, function* () {
    var _a;
    if (!(yield tryResetValidityIndicator()))
      return;
    (_a = state.selectedProfileEl) == null ? void 0 : _a.removeClass("selected");
    el == null ? void 0 : el.addClass("selected");
    state.selectedProfileEl = el;
    state.selectedProfileName = name2;
    setCMEditorContent(state.profilesMap.get(name2));
  });
  const onRemoveProfileClick = (name2, el) => {
    if (el === state.selectedProfileEl)
      onProfileClick(BaseProfileName, state.baseProfileEl);
    state.profilesMap.delete(name2);
    state.editedProfile.add(name2);
    profilesContainer.removeChild(el);
  };
  const addProfile = (profile, selected) => {
    const button = new import_obsidian.ExtraButtonComponent(profilesContainer);
    const el = button.extraSettingsEl;
    el.accessKey = profile.title;
    button.onClick(() => onProfileClick(profile.title, el));
    el.addClass("rules-profile-button");
    el.setText(profile.title);
    if (profile.title != BaseProfileName) {
      const closeEl = new import_obsidian.ExtraButtonComponent(el).setIcon("cross").extraSettingsEl;
      closeEl.onClickEvent((ev) => {
        ev.stopPropagation();
        onRemoveProfileClick(profile.title, el);
      });
      closeEl.addClass("rules-profile-close");
    } else {
      state.baseProfileEl = el;
    }
    if (selected) {
      onProfileClick(profile.title, el);
    }
  };
  for (const profile of plugin.settings.profiles) {
    addProfile(profile, profile.title === plugin.settings.activeProfile);
  }
  const addButton = new import_obsidian.ExtraButtonComponent(profilesContainer).onClick(() => {
    if (state.profilesMap.size > 5) {
      new import_obsidian.Notice("You can only have 6 profiles at most.");
      return;
    }
    new StringInputModal(app, (value) => {
      if (state.profilesMap.has(value))
        return false;
      if (value === void 0)
        return true;
      state.profilesMap.set(value, "");
      state.editedProfile.add(value);
      profilesContainer.removeChild(addButton.extraSettingsEl);
      addProfile({ title: value, content: "" }, true);
      profilesContainer.appendChild(addButton.extraSettingsEl);
      return true;
    }).open();
  });
  addButton.extraSettingsEl.addClass("rules-profile-button");
  addButton.extraSettingsEl.setText("+");
  return convertRulesEditor;
}
var StringInputModal = class extends import_obsidian.Modal {
  constructor(app2, onSubmit) {
    super(app2);
    this.submitEnterCallback = (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.onSubmit = onSubmit;
  }
  submit() {
    if (this.onSubmit(this.result))
      this.close();
    else
      this.err.setText("Profile already exists!");
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText("Profile Name");
    const container = contentEl.createDiv();
    const textComponent = new import_obsidian.TextComponent(container);
    this.err = container.createEl("p");
    textComponent.inputEl.style.width = "100%";
    textComponent.onChange((value) => this.result = value).inputEl.addEventListener("keydown", this.submitEnterCallback);
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => this.submit()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ConfirmationModal = class extends import_obsidian.Modal {
  constructor(app2, prompt, conformCb) {
    super(app2);
    this.contentEl.createEl("p", { text: prompt });
    new import_obsidian.Setting(this.contentEl).addButton(
      (button) => button.setButtonText("Conform").onClick(() => __async(this, null, function* () {
        yield conformCb(true);
        this.close();
      }))
    ).addButton(
      (button) => button.setButtonText("Cancel").onClick(() => __async(this, null, function* () {
        yield conformCb(false);
        this.close();
      }))
    );
  }
};

// src/global_commands.ts
var import_obsidian2 = require("obsidian");
function getAllCommands(plugin) {
  const format = {
    id: "typing-trans-toggle-format",
    name: "Toggle Auto Formatting",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleAutoFormat();
    })
  };
  const zone = {
    id: "typing-trans-toggle-zone-indicator",
    name: "Toggle Auto Formatting Zone Indicator",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleIndicator();
    })
  };
  const ret = [format, zone];
  const useProfileX = (i) => __async(this, null, function* () {
    const profs = plugin.settings.profiles;
    if (i >= profs.length) {
      new import_obsidian2.Notice(`Profile ${i} doesn't exist`);
      return;
    }
    const { title, content: content2 } = profs[i];
    if (plugin.settings.activeProfile === title)
      return;
    const newRule = title === BaseProfileName ? content2 : profs[0].content + "\n" + content2;
    plugin.configureProfile(title, newRule);
  });
  for (let i = 0; i < 6; i++) {
    const useProfileCommand = {
      id: "typing-trans-p" + i.toString(),
      name: "apply profile " + i.toString() + (i === 0 ? " (global)" : ""),
      editorCallback: (_e, _v) => __async(this, null, function* () {
        yield useProfileX(i);
      })
    };
    ret.push(useProfileCommand);
  }
  return ret;
}

// src/main.ts
var ProgramTxn = import_state2.Annotation.define();
var deubgExt = import_state2.StateField.define({
  create: (_state) => {
    return 0;
  },
  update: (value, tr) => {
    if (tr.docChanged) {
      tr.changes.iterChanges((a, b, c, d, insert) => {
        console.log(a, b, c, d, insert.sliceString(0));
      });
    }
    return value;
  }
});
var TypingTransformer = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.configureProfile = (title, ruleString) => __async(this, null, function* () {
      this.settings.activeProfile = title;
      this.settings.convertRules = ruleString;
      this.configureRules(ruleString);
      this.updateProfileStatus();
      yield this.saveSettings();
    });
    this.configureRules = (ruleString) => {
      this.rules = new Rules(ruleString);
    };
    this.checkRules = (ruleString) => {
      return new Rules(ruleString, true).errors;
    };
    this.configureActiveExtsFromSettings = () => {
      const activeIds = [1 /* Conversion */, 0 /* SideInsert */];
      const { debug, zoneIndicatorOn, autoFormatOn } = this.settings;
      debug ? activeIds.push(4 /* Debug */) : null;
      zoneIndicatorOn ? activeIds.push(2 /* ZoneIndicator */) : null;
      autoFormatOn ? activeIds.push(3 /* AutoFormat */) : null;
      this.activeExts.forEach((_ext, idx) => this.activeExts[idx] = []);
      activeIds.forEach((extid) => this.activeExts[extid] = this.availablExts[extid]);
    };
    this.toggleAutoFormat = () => __async(this, null, function* () {
      this.settings.autoFormatOn = !this.settings.autoFormatOn;
      yield this.saveAndReloadPlugin();
    });
    this.toggleDebugLog = () => __async(this, null, function* () {
      this.settings.debug = !this.settings.debug;
      yield this.saveAndReloadPlugin();
    });
    this.toggleIndicator = () => __async(this, null, function* () {
      this.settings.zoneIndicatorOn = !this.settings.zoneIndicatorOn;
      yield this.saveAndReloadPlugin();
    });
    this.saveAndReloadPlugin = () => __async(this, null, function* () {
      yield this.saveSettings();
      this.configureActiveExtsFromSettings();
      this.app.workspace.updateOptions();
    });
    this.spotLibertyZone = ({ view, docChanged }) => {
      if (!docChanged) {
        return;
      }
      const state = view.state;
      const mainSel = state.selection.asSingle().main;
      if (mainSel.anchor != mainSel.head) {
        return;
      }
      const line = state.doc.lineAt(mainSel.anchor);
      const from = line.from;
      const to = mainSel.anchor;
      if (from == to) {
        return;
      }
      for (const pos of this.specialSections) {
        if (pos.start.line <= line.number - 1 && line.number - 1 <= pos.end.line) {
          return;
        }
      }
      const checkInBlock = (blocks2, offset) => {
        for (let i = blocks2.length - 2; i > -1; i -= 2) {
          if (blocks2[i] < offset && offset <= blocks2[i + 1]) {
            return { exist: true, from: blocks2[i], to: blocks2[i + 1] };
          }
        }
        return { exist: false, from: 0, to: 0 };
      };
      const blocks = getBlockRanges(line.text, to - from);
      const r = checkInBlock(blocks.emphasis, to - from);
      if (r.exist) {
        const txt2 = state.sliceDoc(from + r.from, from + r.to);
        let i;
        for (i = 0; txt2[i] == txt2[0] && i < r.to; i++) {
          log("format: skip emphasis head", i, txt2[i]);
        }
        return { from: from + r.from + i, to };
      }
      const spBlocks = blocks.special;
      if (checkInBlock(spBlocks, to - from).exist) {
        return;
      }
      const txt = state.sliceDoc(from, to);
      for (let i = txt.length - 2; i > 0; i--) {
        const ch = txt[i];
        if (ch != " " && PUNCTS.has(ch) && !checkInBlock(spBlocks, i).exist) {
          return { from: from + i, to };
        }
      }
      return { from, to };
    };
    this.addLiberty = (update) => {
      const range = this.spotLibertyZone(update);
      if (range === void 0 || !update.selectionSet) {
        return;
      }
      const from = range.from, to = range.to;
      const toUpdate = update.view.state.doc.sliceString(from, to);
      if (PUNCTS.has(toUpdate.charAt(toUpdate.length - 1))) {
        const trimmed = toUpdate.trim();
        if (trimmed === "") {
          return;
        }
        const lspace = toUpdate.length - toUpdate.trimStart().length;
        const rspace = toUpdate.length - toUpdate.trimEnd().length;
        log(
          "foramt: trigger char: %s, toUpdate: %s, lspace: %d, rspace: %d",
          toUpdate.charAt(toUpdate.length - 1),
          toUpdate,
          lspace,
          rspace
        );
        const formatted = formatLine(trimmed);
        if (formatted === trimmed) {
          return;
        }
        update.view.dispatch({ changes: { from: from + lspace, to: to - rspace, insert: formatLine(trimmed) }, annotations: ProgramTxn.of(true) });
      }
    };
    this.convertFilter = (tr) => {
      if (!tr.docChanged || tr.annotation(ProgramTxn)) {
        return tr;
      }
      let shouldHijack = true;
      const changes = [];
      const { insertTrigSet, deleteTrigSet, lmax, rmax } = this.rules;
      tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        if (!shouldHijack) {
          return;
        }
        let trigger;
        if (fromA === toA && fromB + 1 === toB) {
          trigger = inserted.sliceString(0);
          if (!insertTrigSet.has(trigger)) {
            shouldHijack = false;
          }
        } else if (fromA + 1 === toA && fromB === toB) {
          const delChar = tr.startState.sliceDoc(fromA, toA);
          if (!deleteTrigSet.has(delChar)) {
            shouldHijack = false;
          }
          trigger = DEL_TRIG;
          fromA = toA;
          fromB += 1;
          toB = fromB + 1;
        } else {
          shouldHijack = false;
        }
        if (!shouldHijack) {
          return;
        }
        let leftIdx = fromB - lmax;
        let insertPosFromLineHead = lmax;
        if (leftIdx < 0) {
          insertPosFromLineHead = lmax + leftIdx;
          leftIdx = 0;
        }
        const input = tr.startState.sliceDoc(leftIdx, fromB + rmax);
        const rule = this.rules.match(input, trigger, insertPosFromLineHead);
        if (rule != null) {
          log("hit covert rule: %s", rule.left.join(""));
          const change = rule.mapToChanges(fromB);
          change.annotations = ProgramTxn.of(true);
          changes.push(change);
        } else {
          shouldHijack = false;
        }
      });
      if (shouldHijack) {
        tr = tr.startState.update(...changes);
      }
      return tr;
    };
    this.sidesInsertFilter = (tr) => {
      if (!tr.docChanged || tr.annotation(ProgramTxn)) {
        return tr;
      }
      let shouldHijack = true;
      const changes = [];
      tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        const char = inserted.sliceString(0);
        if (!shouldHijack || fromA == toA || toB != fromB + 1 || !this.rules.sideInsertMap.has(char)) {
          shouldHijack = false;
          return;
        }
        const insert = this.rules.sideInsertMap.get(char);
        changes.push({ changes: { from: fromA, insert: insert.l }, annotations: ProgramTxn.of(true) });
        changes.push({ changes: { from: toA, insert: insert.r }, annotations: ProgramTxn.of(true) });
      });
      if (shouldHijack) {
        tr = tr.startState.update(...changes);
      }
      return tr;
    };
    this.updateProfileStatus = () => {
      this.profileStatus.setText(`Active Profile: ${this.settings.activeProfile}`);
    };
  }
  onload() {
    return __async(this, null, function* () {
      console.log("loading typing transformer plugin");
      yield this.loadSettings();
      initLog(this.settings);
      yield charliberty_default(charliberty_bg_default);
      this.specialSections = [];
      this.activeExts = [];
      this.availablExts = [
        import_state2.EditorState.transactionFilter.of(this.sidesInsertFilter),
        import_state2.EditorState.transactionFilter.of(this.convertFilter),
        libertyZone(this.spotLibertyZone),
        import_view3.EditorView.updateListener.of(this.addLiberty),
        deubgExt
      ];
      this.availablExts.forEach((_, idx) => this.activeExts[idx] = []);
      this.configureRules(this.settings.convertRules);
      this.configureActiveExtsFromSettings();
      this.registerEditorExtension(this.activeExts);
      this.registerEvent(this.app.metadataCache.on("changed", (_f, _d, meta2) => {
        var _a;
        this.specialSections.length = 0;
        (_a = meta2.sections) == null ? void 0 : _a.forEach((sec) => {
          if (sec.type == "code" || sec.type == "match") {
            this.specialSections.push(sec.position);
          }
        });
      }));
      this.addSettingTab(new SettingTab(this.app, this));
      for (const cmd of getAllCommands(this)) {
        this.addCommand(cmd);
      }
      this.profileStatus = this.addStatusBarItem();
      this.updateProfileStatus();
    });
  }
  onunload() {
    console.log("unloading typing transformer plugin");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const data = yield this.loadData();
      let defaultSource = DEFAULT_SETTINGS;
      if (data && !data.hasOwnProperty("profiles") && data.convertRules != DEFAULT_SETTINGS.convertRules) {
        const cloned = structuredClone(DEFAULT_SETTINGS);
        cloned.profiles[0].content = data.convertRules;
        defaultSource = cloned;
      }
      this.settings = Object.assign({}, defaultSource, data);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};

/* nosourcemap */